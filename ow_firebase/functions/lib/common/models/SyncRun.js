"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SyncRun = void 0;

var moment = _interopRequireWildcard(require("moment"));

var _SyncRunStatus = require("../enums/SyncRunStatus");

var _SyncMethod = require("../enums/SyncMethod");

var _Sync = require("./Sync");

var _utils = require("../utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A Sync run is a single run of a single sync method.
 * When a sync is triggered, a run is created.
 * 
 * Runs start in a `pending` state, when it is running, it will move 
 * to a `running` status,  and then move to `error` or `success`
 * SyncRuns will eventually have subscribers which are notified
 * when a run fails or succeeds for any reason.
 * 
 * For now, we will just log to console when this happens
 * 
 */
var SyncRun =
/*#__PURE__*/
function () {
  //auto generated by Cloudstore
  // we need a sync method + sync verb maybe...
  //array of email addresses
  //unix timestamp
  //unix timestamp
  //TODO: constructor or builder
  function SyncRun(orgId, syncId, syncMethod, subscribers) {
    _classCallCheck(this, SyncRun);

    Object.defineProperty(this, "id", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "orgId", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "syncId", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "syncMethod", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "subscribers", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "startedAt", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "finishedAt", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "status", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: _SyncRunStatus.SyncRunStatus.pending
    });
    Object.defineProperty(this, "results", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "warnings", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "errors", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: []
    });
    this.orgId = orgId;
    this.syncId = syncId;
    this.syncMethod = syncMethod;
    this.subscribers = subscribers;
  }
  /**
   * Run the syncRun
   * @param param0 
   */


  _createClass(SyncRun, [{
    key: "run",
    value: function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(_ref) {
        var fs, sync, validationResult, pullFromResult, pushToResult;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                fs = _ref.fs;

                if (!(this.status !== _SyncRunStatus.SyncRunStatus.pending)) {
                  _context.next = 3;
                  break;
                }

                throw new Error("SyncRun can only be run when in a pending state. Found state: ".concat(this.status));

              case 3:
                this.startedAt = (0, moment)().valueOf();
                console.log("startedAt", this.startedAt);
                this.status = _SyncRunStatus.SyncRunStatus.running;
                _context.next = 8;
                return _Sync.Sync.getSync({
                  orgId: this.orgId,
                  id: this.syncId,
                  fs: fs
                });

              case 8:
                sync = _context.sent;
                console.log("SyncRun.run: running sync:", sync);

                if (sync) {
                  _context.next = 13;
                  break;
                }

                this.errors.push("Could not find sync with SyncId: ".concat(this.syncId));
                return _context.abrupt("return", this.abortSync({
                  fs: fs
                }));

              case 13:
                _context.next = 15;
                return this.save({
                  fs: fs
                });

              case 15:
                _context.t0 = this.syncMethod;
                _context.next = _context.t0 === _SyncMethod.SyncMethod.validate ? 18 : _context.t0 === _SyncMethod.SyncMethod.pullFrom ? 32 : _context.t0 === _SyncMethod.SyncMethod.pushTo ? 40 : 48;
                break;

              case 18:
                _context.prev = 18;
                console.log("SyncRun.run running validate sync"); //TODO: change this to use the a validate method instead

                _context.next = 22;
                return sync.datasource.validate(this.orgId, fs);

              case 22:
                validationResult = _context.sent;
                this.results = validationResult.results;
                this.warnings = validationResult.warnings;
                _context.next = 31;
                break;

              case 27:
                _context.prev = 27;
                _context.t1 = _context["catch"](18);
                console.log('error', _context.t1);
                this.errors.push(_context.t1.message);

              case 31:
                return _context.abrupt("break", 49);

              case 32:
                console.log("SyncRun.run running pullFrom sync");
                _context.next = 35;
                return sync.datasource.pullDataFromDataSource(this.orgId, fs, {
                  filterAfterDate: sync.lastSyncDate
                });

              case 35:
                pullFromResult = _context.sent;
                this.results = ["Pulled ".concat(pullFromResult.results.length, " items from dataSource")];
                this.warnings = ["Pull resulted in ".concat(pullFromResult.warnings.length, " warnings")];
                this.errors = pullFromResult.errors;
                return _context.abrupt("break", 49);

              case 40:
                console.log("SyncRun.run running pushTo sync");
                _context.next = 43;
                return sync.datasource.pushDataToDataSource(this.orgId, fs, {
                  filterAfterDate: sync.lastSyncDate
                });

              case 43:
                pushToResult = _context.sent;
                this.results = pushToResult.results;
                this.warnings = pushToResult.warnings;
                this.errors = pushToResult.errors;
                return _context.abrupt("break", 49);

              case 48:
                console.error("Other SyncMethods not implemented yet.");

              case 49:
                if (!(this.errors.length > 0)) {
                  _context.next = 51;
                  break;
                }

                return _context.abrupt("return", this.abortSync({
                  fs: fs
                }));

              case 51:
                return _context.abrupt("return", this.finishSync({
                  fs: fs
                }));

              case 52:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[18, 27]]);
      }));

      function run(_x) {
        return _ref2.apply(this, arguments);
      }

      return run;
    }()
  }, {
    key: "abortSync",
    value: function () {
      var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(_ref3) {
        var fs;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                fs = _ref3.fs;
                console.warn("aborting sync with errors:", this.errors);
                this.status = _SyncRunStatus.SyncRunStatus.failed;
                this.finishedAt = (0, moment)().valueOf();
                return _context2.abrupt("return", this.save({
                  fs: fs
                }));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function abortSync(_x2) {
        return _ref4.apply(this, arguments);
      }

      return abortSync;
    }()
  }, {
    key: "finishSync",
    value: function () {
      var _ref6 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(_ref5) {
        var fs;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                fs = _ref5.fs;
                console.log("finished sync with results:", this.results);
                console.log("finished sync with warnings:", this.warnings);
                this.status = _SyncRunStatus.SyncRunStatus.finished;
                this.finishedAt = (0, moment)().valueOf();
                return _context3.abrupt("return", this.save({
                  fs: fs
                }));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function finishSync(_x3) {
        return _ref6.apply(this, arguments);
      }

      return finishSync;
    }()
    /**
     * Create a new SyncRun in FireStore
     */

  }, {
    key: "create",
    value: function create(_ref7) {
      var fs = _ref7.fs;
      console.log('SyncRun.create');
      var newRef = fs.collection('org').doc(this.orgId).collection('syncRun').doc();
      this.id = newRef.id;
      return this.save({
        fs: fs
      });
    }
  }, {
    key: "save",
    value: function save(_ref8) {
      var _this = this;

      var fs = _ref8.fs;
      console.log("saving SyncRun"); //TODO: do we want this to merge?

      return fs.collection('org').doc(this.orgId).collection('syncRun').doc(this.id).set(this.serialize()).then(function (ref) {
        console.log('Finished saving SyncRun: ', _this.id);
        return _this;
      });
    }
    /**
     * Serialize the SyncRun for saving or transmission
     */

  }, {
    key: "serialize",
    value: function serialize() {
      return {
        id: this.id,
        orgId: this.orgId,
        syncId: this.syncId,
        syncMethod: this.syncMethod.toString(),
        subscribers: this.subscribers,
        startedAt: (0, moment)(this.startedAt).toDate(),
        finishedAt: (0, moment)(this.finishedAt).toDate(),
        status: this.status.toString(),
        results: this.results,
        warnings: this.warnings,
        errors: this.errors
      };
    }
    /**
     * deserialize from a firestore snapshot
     * @param sn 
     */

  }], [{
    key: "deserialize",
    value: function deserialize(sn) {
      var _sn$data = sn.data(),
          id = _sn$data.id,
          orgId = _sn$data.orgId,
          syncId = _sn$data.syncId,
          syncMethod = _sn$data.syncMethod,
          subscribers = _sn$data.subscribers,
          startedAt = _sn$data.startedAt,
          finishedAt = _sn$data.finishedAt,
          status = _sn$data.status,
          results = _sn$data.results,
          warnings = _sn$data.warnings,
          errors = _sn$data.errors; //TODO not sure the enums will des properly


      var des = new SyncRun(orgId, syncId, syncMethod, subscribers);
      des.id = id;
      des.startedAt = startedAt;
      des.finishedAt = finishedAt;
      des.status = status;
      des.results = results;
      des.warnings = warnings;
      des.errors = errors;
      return des;
    }
    /**
     * Get the sync rungs for a given id
     */

  }, {
    key: "getSyncRuns",
    value: function getSyncRuns(_ref9) {
      var orgId = _ref9.orgId,
          syncId = _ref9.syncId,
          fs = _ref9.fs;
      return fs.collection('org').doc(orgId).collection('syncRun').where('syncId', '==', syncId).get().then(function (sn) {
        return (0, _utils.snapshotToSyncRunList)(sn);
      });
    }
    /**
     * Get the sync run for the given id
     * @param param0 
     */

  }, {
    key: "getSyncRun",
    value: function getSyncRun(_ref10) {
      var orgId = _ref10.orgId,
          id = _ref10.id,
          fs = _ref10.fs;
      return fs.collection('org').doc(orgId).collection('syncRun').doc(id).get().then(function (sn) {
        return SyncRun.deserialize(sn);
      });
    }
  }]);

  return SyncRun;
}();

exports.SyncRun = SyncRun;